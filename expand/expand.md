1. JS's asynchronous nature is an issue because of the fact that most programming languages are rarely asynchronous and simply just run from top to down, left to right, only jumping when necessary(e.g. functions and if statements). Asynchronicity allows for an unclear flow of code that is completely unorthodox and is based on real world time. That can make it hard to follow the code. The loose typing is a disadvantage because at times, it can create hard to debug bugs based on poor type conversion. Normally, if there are two different types, it would return an error if we did addition, but js just evaluates the types and adds them. This causes bugs where one variable may be not converted into a certain type and as a result, the behavior of the arithmetic is different than expected, but that's not apparent to the programmer. The programmer may look at the code confused, until they find out that it's due to type conversion. Lastly, the fact that JS runs on a web platform means that it's limited in the amount of tools you can use to debug it. Of course, with nodejs, we can use the vscode debugger, but if the js is integrated with a website, then we have to use our browser debugger.
2. It's loosely typed because of the fact that remembering to parse is also an issue. If we want to print something out or concatenate a number we found from a function into a string to display to the user, we'd have to parse it over and over. Not to mention that on a website, we would need to gather responses from all sorts of different data types, some of which are more unclear than others. That's even more parsing needed. There is a case to be made for loose typing for JS. They made it asynchronous because the way a website works could require many asynchronous lines of code. The website is required to send requests to the server and receive requests, which requires the usage of asynchronous programming in order to wait for a response. A website may need to check for responses timing out. On the internet, keeping track of events in a timeline is very important, as webpages load a bit slower than native applications. This is just one example for why it needs asynchronicity.
3. A compiled language takes the code of a program and re-writes it into a binary file to be directly run by the computer. An interpreted language reads every line and converts it into binary on the go to run it. JS is an interpreted language since it runs line by line on a browser without the need for a compiler. While it does need to be run in a browser(or for more general interpreted languages, a special environment) to be interpreted as well as the fact that it's a bit slower than compiled languages since it operates in a lower-context environment due to interpretation, it also benefits from the fact that it's cross-platform. As long as every user has a browser, they can run a JS program without the need to worry about whether or not the program works on their specific OS. Another benefit is that we don't have to wait for compilation. It executes code immediately, whereas compiled languages such as C and C++ require the programmer to compile before doing anything.
4. Since frameworks are modify how you use JS, it's definitely better to master JS itself first before using frameworks. Frameworks may change specific properties or introduce new things that bind to specific properties of JS. If you do not have a good grasp on JS, then you'd have to catch up on JS and learn the framework itself anyways. You'd have to understand how the framework changes JS.
5. This lab teaches the basics of actually programming in JS, which powers the CRUD app that we're making. Without it, we'd be lost on where to start for JS. Even if we aren't programming in JS, we can use this as programming review.  
